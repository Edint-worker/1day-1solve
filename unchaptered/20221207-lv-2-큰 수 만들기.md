### 문제 설명

어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

### 제한 조건

- number는 2자리 이상, 1,000,000자리 이하인 숫자입니다.
- k는 1 이상 number의 자릿수 미만인 자연수입니다.

### 입출력 예

| number | k	| return |
| "1924"	| 2	| "94" |
| "1231234"	| 3	| "3234" |
| "4177252841" |	4	| "775841" |

### 첫 번쨰 풀이

Counter 구조 이용해서 풀이하려고 했습니다.
하지만 해당 방법으로 풀게되면 **각 자리수의 합이 최대인 수**가 나오지, **가장 큰 수**가 아니었습니다.

![image](https://user-images.githubusercontent.com/86306802/206646291-90ee99f3-6161-4c99-9c32-fa05bb5b36d6.png)

단일 숫자가 작더라도 맨끝에 있는 1을 지우는 것보다는 맨 앞에 있는 4를 지우는 것이 효율적인 순간이 있습니다.
이 경우에는 단일 우선순위 Counter가 아니라 이중 우선순위 Counter로 풀어야 하지 않나 싶습니다...... 

```javascript
function solution(nums, k) {

    // [설명] 각 자리수가 몇개나 있는지 계산하여 CounterMap형태로 반환
    const counterMap = getCounterMap(nums);
    
    // [설명] 0 부터 한칸씩 숫자를 키워가면서 무엇을 지워야하는지 연산하여, CounterMap형태로 반환
    const removeTargetMap = getRemoveTargetMap(counterMap, k);
    
    // [설명] nums에서 하나씩 꺼내서 removeTargetMap에 있는 값을 기준으로 삼아서 무시하거나, stack(string)안에 하나씩 넣고 완성
    let stack = '';
    for (const numStr of nums) {
        const num = +numStr;
        
        const isRemovedTarget = removeTargetMap.has(num);
        
        const removedTargetCount = removeTargetMap.get(num);
        const isLastRemovedTarget = removedTargetCount === 0;
        
        if (isRemovedTarget && !isLastRemovedTarget) {
            removeTargetMap.set(num, removedTargetCount - 1);
        } else {
            stack += num;
        }
    }
    
    return stack;
    
    
}

function getCounterMap(nums) {
    
    /**
     * Counter는 Dictionary형태의 자료 구조의 일부로 Item의 수를 세는 클래스입니다.
     * Java, Python과는 달리 JavaScript에서는 이와같이 수동으로 구현해야 합니다.
     */
    const counterMap = new Map();
    for (const numStr of nums) {
        
        const num = +numStr;
        const hasNum = counterMap.has(num);
        
        if (hasNum) counterMap.set(num, counterMap.get(num) +1);
        else counterMap.set(num, 1);
    }
    return counterMap;
}

function getRemoveTargetMap(counterMap, deleteCount) {
    
    let accDeleteCount = 0;
    const removeTargetMap = new Map();
    for (let num = 0; num < 10; num ++) {
        
        const hasNum = counterMap.has(num);
        
        if (hasNum) {
            
            const numCount = counterMap.get(num);
            const remainingDeleteCount = deleteCount - accDeleteCount;
            
            if (remainingDeleteCount >= numCount) {
                
                accDeleteCount += numCount;
                removeTargetMap.set(num, numCount);
                
            } else {
                
                if (accDeleteCount === deleteCount) break;
                
                accDeleteCount += remainingDeleteCount;
                removeTargetMap.set(num, remainingDeleteCount);
                
            }
        }
        
    }
    
    return removeTargetMap
    
}
```

### 두 번째 풀이

[Counter 자료구조와 정렬방법](https://smlee729.github.io/python/data%20structure/2015/03/15/1-count-of-maximum.html) 같은데서 나오는 **Item의 수를 세는 특성**이 이 문제를 푸는데 큰 도움이 되지 않는 것 같아요.

그래서 그냥 반복문 통째로 돌렸습니다...
실패 원인은 아래 중단점을 안잡아서 그런 것 같아요.

1. 최댓값은 연산처리할 필요가 없음...

![image](https://user-images.githubusercontent.com/86306802/206651138-3db675fa-5249-4465-ab18-126992e717b8.png)


```
function solution(nums, k) {
    
    const numsArr = nums.split('');
    
    let cnt = 0;
    while(cnt++ < k) {
        for (let idx = 0; idx < numsArr.length - 1 ; idx++) {
            const nowVal = numsArr[idx];
            const nextVal = numsArr[idx + 1];
            
            if (nowVal < nextVal) {
                numsArr.splice(idx, 1);
                break;
            }
        }
    }
    
    return numsArr.slice(0, nums.length - k).join('');
    
}
```
